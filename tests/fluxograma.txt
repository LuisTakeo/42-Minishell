- tokenizar
    -- incluir separação por símbolos especiais (criar função/regra pra cada tipo)
    -- definir tipos de token para comandos, argumentos e flags
    -- verificar se tokens são válidos (validação do comando)
DONE!!!

- expandir vars
    -- expandir variaveis
    -- corrigir separação de token com $ (variáveis de ambiente)
    -- corrigir segfault quando executado apenas com $ (token não salva)

- arvore binaria
    -- validar tokens (operadores) [DONE!!!]
    -- tipar operadores dos tokens [DONE!!!]
    -- construir a arvore // utilizar lista duplamente linkada?
        -- alocar o primeiro nó
        -- buscar pelo ultimo pipe
        // loop
        -- botar o pipe no primeiro nó
        -- o nó da direita da arvore vai receber os comandos com o conteudo a direita do pipe
            -- puxar o conteudo que for 'word' de tokens e transformar em argv
            -- puxar o conteudo que for redir/argumento e jogar em uma lista de redir
            -- retornar o nó alocado com seus conteudos
        -- verificar se há um pipe antes
        -- não houver, chamaar função para construir nó da esquerda (mesma função utilizada para nó da direitaa)
        -- se sim, alocar o nó da esquerda e seguir pro próximo (repetir o loop)

- builtins
    -- implementar exit [DONE!!!]
        -- se nenhum argumento for passado, sai do shell com o status de saída do último comando executado
        -- se um argumento numérico entre 0 e 255 for passado, sai do shell com o status de saída especificado
        -- se um argumento numérico > 255 for passado, sai do shell com o status de saída adaptado para caber no intervalo de 0 a 255 (num % 256)
        -- se um argumento não numérico for passado, imprime mensagem de erro e sai do shell com status de saída 255
        -- se mais de um argumento for passado e o argumento logo após exit for numérico, imprime erro "too many arguments" e não sai do shell
        -- se mais de um argumento for passado e o argumento logo após exit não for numérico, imprime erro "numeric argument required" e sai do shell com status 255
    -- adaptação unset

- parsear e preparar para execução // separar em função quando for único comando
    -- verificar se é um builtin
        --- se sim, executar função de acordo
        --- se não, utilizar fork para execve
    DONE!!!


- fork -> processo pai / processo filho
    -- verificar se é processo filho
    -- void exec(t_list *param, int id)
    -- se tiver mais de um comando (pipe)
    -- 	fork ->

- tratar erros
    -- para todo caso não previsto no PDF, retornar prompt


- ideia recursão tree
    funcao que recebe o nó o fd de saída e a estrutura do minishell